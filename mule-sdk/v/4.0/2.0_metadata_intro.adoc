[[_metadata]]
= Adding DataSense Support

Mule DataSense is a service that displays type metadata for the entities in a Connector. +
Although this feature is optional, MuleSoft strongly recommends that you use DataSense in your connector to make its usage much easier for application developers.


[NOTE]
====
This document assumes that you are familiar with the Connector's architecture, and also familiar with the concept of DataSense from an end-user’s perspective.
//TODO link to Connectors and DataSense doc
====

== What's the Metadata of a Component?

Integration developers often spend great amounts of time simply trying to determine the input and output types for a given Component (Operation, Sources, etc.) so they can transform the data in hand to connect one Component output to the next Component input, having to resort to each API’s documentation to find out what these Parameters are. +
This is an inefficient, fallible, and often frustrating experience. Thanks to the Metadata provided by each
Component, MuleSoft DataSense service can resolve all this information automatically, and present it to the application developer in design time, drastically improving the development speed.

=== Input Metadata

We refer as input Metadata to the type resolution for the Parameters of a Component. Each Parameter can provide either Static or Dynamic Metadata isolated from what kind of Metadata do other Parameters of the same Component expose. Only Operations and Sources can have Parameters with dynamic metadata, while Configurations and Connections will always
have static metadata.


=== Output Metadata

The Output of a Component is also bound to either Static or Dynamic resolution of its Metadata.
For example, a `void` Operation will have Static Metadata indicating that the output of that Operation is of VoidType, while a different Operation that fetches a `User` profile from a remote service can describe dynamically what the structure of the User type is. +

In the <<_structure, Structure>> section we saw that an Operation can output a Result, which contains data for the Payload and the Attributes of the resulting Message. Luckily for us, we are able to describe the Metadata for both of them independently, thus providing a greatly enriched experience for the app developer. Structure of the Attributes is as important as the structure of the Payload, but since not all Components produce Attributes, the dynamic Metadata for them is always optional. +

You'll find that certain return types are forced to describe their Metadata dynamically and may ask why. The answer is consistency, since we have to always think in providing the best experience possible for the app developer, and too generic types are enemies of that.


=== Static Metadata
We’ll use Static Metadata to reference the Metadata that is known at compile time and available from the types in the connector’s jar. Simple java types are part of this static Metadata, as well as custom POJOs defined by the developer in its model. The relevant part is that the structure is well known or can be introspected, without having a dynamic key or a custom resolver.


=== Dynamic Metadata
Dynamic Metadata names the Metadata of a type with an unknown structure at compile time, that has to be resolved based on the configuration of the Connector at design time. +
This has different usages, going from cases where the type itself is known but its structure depends on the service configuration (eg, the system has an Account with fields that can be customized by the user, so its structure has to be discovered each time based on the user’s credentials), all the way to cases where everything is dynamic and the structure described heavily depends on the configured Parameters (eg, the structure described is the payload of a Service operation which also depends on the definition of the Service based on the user sandbox).


We'll see later that in order to resolve Dynamic Metadata, the element has to be associated with a Metadata Resolver that knows how to obtain the desired type structure based on the current Component configuration.

==== Metadata Keys Parameter

In order to describe a Dynamic Metadata structure, we need to
know what type has to be represented.
This type reference is done by defining a `@MetadataKeyId` Parameter in
the operation, that contains the id of the type (eg, Account) which will
be passed to the Metadata Resolver defined for that Parameter.

This means, for example, that if your Operation can save a generic
record to Amazon S3, but you wish to provide a better design time
experience by describing the supported types `Account` and
`Organization`, then one of your Operation parameters will be a type
reference containing either the id `Account` or the id `Organization`,
and this parameter will be used to describe either the Account
structure or the Organization structure for the record to be saved
into the bucket, depending on what the app developer decides to use.

Having a `@MetadataKeyId` Parameter is not always required, since you
may not have multiple structures to define but just one, which varies
dynamically based on the configuration.
For example, having a `User` entity whose structure changes based on
whether the connection credentials are those of an admin or not.


==== Implementation Overview

Implementing Dynamic DataSense support starts with defining what type of
Metadata we want to provide and for which element. Once that is defined
we'll make use of a combination of annotations and custom implementations
of different Metadata resolvers (ie: `@MetadataKeyId(BucketKeysResolver.class)`),
depending on the desired use case.
In the next sections you'll find detailed explanation of how to implement
each of the cases described above and their combinations.

===== Metadata Resolvers

Whenever we want to obtain a dynamic element for DataSense we are going to
implement a Metadata resolver. There are many different kinds of resolvers,
each with their own responsibility and use cases that will be explained later,
but they all share some main concepts:

- Category Name: This is the name of the group that relates different
Metadata resolvers so they can work together.

- Resolver Name: This is the name that uniquely identifies a given Metadata
resolver. Different resolvers can belong to the same `category` but _must_
have different resolver names.

- The Metadata Context: Provides access to the all the Configuration and Connection
elements used during Metadata fetch invocation, along with a set of utility components
like a `TypeLoader` and a `TypeBuilder`. Is important to always use the implementations
provided by the context when creating a dynamic type.
