[[_metadata]]
= Adding DataSense Support

Mule DataSense is a service that displays type metadata for the entities in a Connector. +
Although this feature is optional, MuleSoft strongly recommends that you use DataSense in your connector to make its usage much easier for application developers.


[NOTE]
====
This document assumes that you are familiar with the Connector's architecture, and also familiar with the concept of DataSense from an end-user’s perspective.
//TODO link to Connectors and DataSense doc
====

== What's the Metadata of a Component?

Integration developers often spend great amounts of time simply trying to determine the input and output types for a given Component (Operation, Sources, etc.) so they can transform the data in hand to connect one Component output to the next Component input, having to resort to each API’s documentation to find out what these Parameters are. +
This is an inefficient, fallible, and often frustrating experience. Thanks to the Metadata provided by each
Component, MuleSoft DataSense service can resolve all this information automatically, and present it to the application developer in design time, drastically improving the development speed.

=== Static Metadata
We’ll use Static Metadata to reference the Metadata that is known at compile time and available from the types in the connector’s jar. Simple java types are part of this static Metadata, as well as custom POJOs defined by the developer in its model. The relevant part is that the structure is well known or can be introspected, without having a dynamic key or a custom resolver.

=== Dynamic Metadata
Dynamic Metadata names the Metadata of a type with an unknown structure at compile time, that has to be resolved based on the configuration of the Connector at design time. +
This has different usages, going from cases where the type itself is known but its structure depends on the service configuration (eg, the system has an Account with fields that can be customized by the user, so its structure has to be discovered each time based on the user’s credentials), all the way to cases where everything is dynamic and the structure described heavily depends on the configured Parameters (eg, the structure described is the payload of a Service operation which also depends on the definition of the Service based on the user sandbox).

We'll see later that in order to resolve Dynamic Metadata, the element has to be associated with a Metadata Resolver that knows how to obtain the desired type structure based on the current Component configuration.


=== Input Metadata

We refer as input Metadata to the type resolution for the Parameters of a Component. Each Parameter can provide
either Static or Dynamic Metadata isolated from what kind of Metadata do other Parameters of the same Component expose.


=== Output Metadata

The Output of a Component is also bound to either Static or Dynamic resolution of its Metadata.
For example, a `void` Operation will have Static Metadata indicating that the output of that Operation is of VoidType, while a different Operation that fetches a `User` profile from a remote service can describe dynamically what the structure of the User type is. +

In the <<_structure, Structure>> section we saw that an Operation can output a Result, which contains data for the Payload and the Attributes of the resulting Message. Luckily for us, we are able to describe the Metadata for both of them independently, thus providing a greatly enriched experience for the app developer. Structure of the Attributes is as important as the structure of the Payload, but since not all Components produce Attributes, the dynamic Metadata for them is always optional. +

You'll find that certain return types are forced to describe their Metadata dynamically and may ask why. The answer is consistency, since we have to always think in providing the best experience possible for the app developer, and too generic types are enemies of that.
