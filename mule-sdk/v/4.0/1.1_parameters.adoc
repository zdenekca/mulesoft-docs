[[_parameters]]
= Parameters
:keywords: mule, sdk, parameter

== What are they?

Parameters are configurable arguments that belong to a given entity. 
Their purpose is to provide the information needed by the entity in order be configured so it can work properly.

Let's see an example which is as easy as you can get:

[source, java, linenums]
----
@Parameter
private String foo;
----

Each parameter contains the following information:

* A type that restricts the kind of value the parameter can have. 
* A name that identifies it

== Modifiers

Parameters are highly customizable according to your needs, so let's see
a few modifiers you can use while defining a parameter to specify the right kind of behaviour or restrictions for it.

==== Expression Support

An `ExpressionSupport` describes the parameter’s relationship with DataWeave expression values. 

There’re three possible values:

* `REQUIRED`: The parameter only accepts expressions.
* `SUPPORTED` (default): The parameter can handle both expressions and simple values. 
* `NOT_SUPPORTED`: The parameter requires static values. Expressions are not supported.

This values can be simply configured just by adding the `@Expression` annotation.

[source, java, linenums]
----
@Parameter
@Expression(SUPPORTED)
private String foo;
----

So, in the example above we defined a parameter named `foo` of type `String` that
can have either a static value (like `"bar"`) or an expression (like `"\#[vars.foo]"`).

==== Optionality

Parameters can be either required or optionals. 

Sometimes a parameter specifies information that is crucial to what we are trying to do (like the host name while doing an HTTP Request) 
that there is no way in which we can continue without it being set,
and sometimes we can manage to operate without that information or just using a default value (assuming that a port would be 80 in an HTTP listener).

A parameter is required by default, but we can easily change that by annotating it with `@Optional`.

Let's look at a simple example.

[source, java]
----
@Parameter
@Optional(defaultValue="80")
private Integer port;
----

Take into account that `@Optional` only accepts `String` values, but the SDK will autoconvert it to your parameter's type.

If and only if the parameter is not required, it can also have a default value. 
Additionally if the parameter supports expressions, this default value might be a DataWeave expression.

=== Using @Alias 

The name of each parameter will be the name given to the field in which it's defined. We can override this name by using the `@Alias` annotation.

Example:

----
@Parameter
@Optional
@Alias("class")
private String clazz;
----

As you see, by using `@Alias` we can name the parameter as a Java reserverd word, something that wouldn't be possible by 
just naming the field as the reserved word.

== Operation's parameters

An operation's parameter is just another argument of the operation's method. 

It doesn't need to be annotated with `@Parameter`, just look at `foo` in the example below.

[source, java]
----
public void method(String foo){}
----


== Using complex types

Now, let's move to more complex parameters instead of using simple types like strings and integers.

[source, java]
----
@Parameter
@Optional
private Options options;
----

Where `Options` is an Object defined by us as:

[source, java]
----
public class Options {

    @Parameter
    public String color;

    @Parameter
    @Optional
    public String mode;

    public String getColor(){
        return color;
    }

    public void setColor(String color){
        this.color = color;
    }

    public String getMode(){
        return mode;
    }

    public void setMode(String mode){
        this.mode = mode;
    }
}
----

A few notes about this example:

* The entire parameter `Options` is used as an optional parameter, so if you decide to use it you need to fullfil that all the required parameters inside `Options` have been set.
* If *options* is not configured, it value will be *null* (see <<_null_safe, NullSafe>> for altering this behaviour).
* `Options` parameters must be Java bean properties (i.e. they need to have setters and getters matching the fields names).

== Configuring the UI 

There are some annotations used for configuring how the parameters are shown in the UI, 
respecting to how are they ordered, how are they grouped, and other properties that are detailed below.

=== @DisplayName

Specifies a custom label for the element and/or field to be used in the UI.

=== @Example

Sometimes it is handy to provide a simple example regarding the values a parameter can take.

=== @Summary

A short description about the parameter's purpose.

=== @Placement

This annotation enables us to configure two things:

* A relative order within the group in which the parameter is defined. The value is relative meaning that the element with order 10 is on top than one with value 25.

* A tab is a logical way to group parameters together. This attribute specifies the name of the tab in which the parameter should be displayed. If no tab is specified then a default tab is assumed. To display more than one parameter or field in the same the tab then this value should be exactly the same for all of them.

In the following example, *foo* and *bar* will be grouped into the same tab named *Advanced* while *foobar* will be the only parameter in the default tab.

[source, java]
----
  @Parameter
  @Placement(order = 1, tab="Advanced")
  private String foo;

  @Parameter
  @Placement(order = 2, tab="Advanced")
  private String bar;

  @Parameter
  private String foobar;
----

=== @Text

Marks a parameter as one that supports a multi line string input in the UI. 

Note: This annotation should only be used in parameters of *String* type.

=== @Path

Marks a parameter as a path to either a file or a directory. This parameter will be displayed in the UI as a file-picker field. 

Note: This annotation should only be used in parameters of *String* type.

This annotation carry information about:

* type: Whether the path points to a directory, a file, or any of those.
* acceptsUrls: Whether the path parameter supports urls.
* acceptedFileExtensions: A list of file extensions this parameter can handle.

Example:

[source, java]
----
  @Parameter
  @Path(type = FILE, acceptedFileExtensions = "wsdl", acceptsUrls = true)
  private String resourcePath;
----

=== @Password

Marks that the parameter needs masking when it is populated from the UI. 

Note: This annotation should only be used in parameters of *String* type.


==== Putting all together

Now, let's see an example using some of the features explained above.

[source, java]
----
  @Parameter
  @Placement(order = 3, tab="Additional information")
  @Example("My name is Max the Mule and I love MuleSoft!")
  @DisplayName("User biography")
  @Summary("Information related to the user\'s life")
  @Text
  private String biography;
----

= Parameter Groups

=== What are they?

The `@ParameterGroup` annotation allows to define a group of parameters which share some kind of special relationship and thus it makes sense for them to belong to the same group. 

How do we spot them? The parameters that should go inside a `@ParameterGroup` are the ones that *travel together* all the times. 
In other words, you never need just one of them. You need both of them present or none at all.

An example:

[source, java]
----
@ParameterGroup("Fancy Group")
private ConnectionProperties properties;
----

Where `Foo` is defined as:
 
[source, java]
----
public class ConnectionProperties {

    @Parameter
    public String host;

    @Parameter
    @Optional(defaultValue="80")
    public Integer port;

    public String getHost(){
        return host;
    }

    public void setHost(String host){
        this.host = host;
    }

    public Integer getPort(){
        return port;
    }

    public void setPort(Integer port){
        this.port = port;
    }
}
----

The class defining the options parameter group will not have a parameter named *properties*. 
Instead, it will contain the parameters that are defined inside `ConnectionProperties`. Those are:

* A required parameter named host
* An optional parameter named port

In other words, the class defining the parameter group is augmented with this extra parameters and will contain the parameters defined inside of `ConnectionProperties` plus all the other parameters it have declared.

Take into account that each field annotated with `@ParameterGroup` must be a Java bean property (i.e: it needs to have setters and getters matching the field name).


==== Using Parameter Groups in operations
Parameter Groups can also be used as parameters defined as arguments of an <<_operations, Operation>>. 

For example:

[source, java]
----
public void hello(String message, @ParameterGroup ConnectionProperties properties) {
}
----

Operation `hello` will have three parameters: message, host and port.

== POJO vs Parameter Group

`@ParameterGroup` can be configured so it can be written as a child element in the DSL instead of being spread around the component that declared it.
In other words:

Our hello example from above will look like this in the DSL:

[source, xml]
----
<example:hello message="Example message!" host="localhost" port="8080">
----

But if we configured the parameter group using `@ParameterGroup(showInDsl=true)` instead, the DSL would look like:

[source, xml]
----
<example:hello message="Example message!">
    <example:options host="localhost" port="8080"/>
</example:hello>
----

This leads to the following question: When should you use a POJO instead POJO annotated with `@ParameterGroup`?

There are some subtle differences between this two concepts. 
You should definitely use a POJO if you care about the type as a whole and the structure it provides.

When we defined Foo above, we just wanted to keep two parameters that are always configured togheter but they don't represent an entity in our domain.
It was only a handy way of keeping things that are related indeed, but don't me anything in particular.

But if we talk about our `Options` POJO defined above, we do care about the object per se instead of only caring about the parameters it contains.
For instance, it would make sense to have a list of `Options`, because each object is something on its own (in the OOP sense). 
On the otherhand if you can be using a class just for the sake of grouping things that go together but don't have any particular meaning on your module's domain,
which is the purpose of having the parameter group.