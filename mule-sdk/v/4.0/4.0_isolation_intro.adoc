[[_isolation]]
= About Classloading Isolation

To introduce the new classloading schema in Mule 4 we need to understand the classloading problems
that we had in Mule 3.

* Modules were not isolated from each other so is not possible to use different libraries in them.
* Modules were not isolated from the runtime.
* Modules were not isolated from the applications.

This means that modules couldn't ship any library version, since any lib which version doesn't match
with one of other module/application/runtime will end up in not found classes making this a hard problem
for application and module developers.

So in Mule 4, to tackle this problem, there is a brand new classloading schema that
makes the runtime, applications and modules isolated from each other. Each one of them
specifies which *packages* (filtering is made by package and *not* made by class) will
export and make visible for other modules and applications.

// TODO
<<classloading, Learn more about classloading isolation in Mule 4>>

== Modules Classloading Isolation

As said before, in Mule 4 classloading filtering is done by package and not by class,
this means that the modules need to specify which packages is going to export for others to
see. Lucky for you, the SDK makes all this work for you, but it's pretty important that
you, as a module developer, understands this rule.

It's simple, the way that the SDK knows what packages to export is by introspecting
each operation and source return and input types and getting its packages. This means
that you never want to share a package between an exported class and another class that
you *don't* want to export.

The suggested package hierarchy (the one that we use for our modules) is:

----
org.mule.module
\--> .api.*
\--> .internal.*
----

Where _api.*_ contains all the classes that are going to be exported and seen by
the application (Return Types, Subtypes, Input Types, Connection interfaces) and
 _internal.*_ contains all the classes that contains the specific behaviour of the module
(Annotated classes, `Connection` and `Operation implementations`; and internal classes).

=== Knowing the Exported classes

It is recommended that *all* exported classes belongs to the module, it is not a
good practice to return or receive objects from classes that belongs to a library
that the module is using, because could end up in a class clash.

For example, think the next scenario:

We have 2 modules with 2 very different operations, both of them uses the same library "X"
that parses Json files and returns an instance of a `JsonObject` class. One of them uses "X" version `1.1` and
the other one "X" version `2.3`. The `JsonObject` class lives in the same package in both
versions but the implementation is *very* different between each other, which made them incompatible.

The developers of the modules decided that it was a good idea to expose the `JsonObject`
class as the return type of their operation:

Module 1
[source, java]
----
public JsonObject getEmployee(@Connection connection, String id) {
  return new JsonObject(connection.getById(id));
}
----

Module 2
[source, java]
----
public JsonObject getAllProducts(@Connection connection) {
  return new JsonObject(connection.getProdsJson());
}
----

But now when developing a Mule application, and the Mule Dev tries to use both modules, *one and only one*
of the two classes implementations will be loaded, since they have exactly the same full qualified name, but not only that!
since classloading filtering is done by package all the other classes that lives in the same package
of that class are going to be exported, resulting in much more complex possible errors.

This will end up in a bunch of `ClassNotFound` and `MethodNotFoundException` between others.

=== The @Export annotation

For extreme corner or complex cases when for some reason a module requires to export a class
that is not automatically exported by the SDK, exist the `@Export` annotation.

The `@Export` annotation receives an array of classes to be exported.

[WARNING]
Take in mind that exporting a class will end up exporting all the classes in the same
package that the exported class.
