[[_oauth_configuring]]
= Configuring an OAuth enabled module

Another important aspect of an OAuth enabled modules is how to use it. As much as the SDK does to hide the complexities of 
the OAuth protocol, things like the OAuth dance are unavoidable. The SDK's approach to this problem is to standarize the 
expirience of all OAuth modules to keep simplifying the user's experience.

In this article we'll discuss the steps a user must take 
in order to use the module.

== Synthetic Parameters

On top of everything that was explicitly defined in that Connection Provider, the SDK will automatically add some extra 
parameters automatically and will also inject the proper behavior for them.

[options="header"]
|===
|Parameter Name|Required|Expressions|Default Value|Description
|resourceOwnerId
|NO
|SUPPORTED
|N/A
|In order to support multi tenancy, users can here specify the id of the tenant which owns the associated access and refresh tokens. 
When performing the authorization dance, this value will provide the id of the obtained token. When a component needs to obtain a new 
connection, it acts as a default owner id to use.

|consumerKey
|YES
|NOT_SUPPORTED
|N/A
|The OAuth consumerKey as registered with the service provider

|consumerSecret
|YES
|NOT_SUPPORTED
|N/A
|The OAuth consumerSecret as registered with the service provider

|authorizationUrl
|NO
|NOT_SUPPORTED
|Value provided in the @AuthorizationCode annotation
|The service provider’s authorization URL

|accessTokenUrl
|NO
|NOT_SUPPORTED
|Value provided in the @AuthorizationCode annotation
|The service provider’s access token URL

|state
|NO
|REQUIRED
|N/A
|A String value that you send when the OAuth dance is initiated and that is returned back by the service provider 
alongside the token callback. It is used to correlate dance initiations with token callbacks. Most common use case of 
this attribute is multitenancy.

|scope
|NO
|NOT_SUPPORTED
|Value provided in the @AuthorizationCode annotation
|The OAuth scopes to be requested during the dance. If not provided, it will default to those in the annotation

|listenerConfig
|YES
|NOT_SUPPORTED
|N/A
|A reference to an <http:listener-config /> to be used in order to create the listener that will catch the access token callback endpoint.

|callbackPath
|YES
|NOT_SUPPORTED
|N/A
|The path of the access token callback endpoint

|authorizePath
|YES
|NOT_SUPPORTED
|N/A
|The path of the local http endpoint which triggers the OAuth dance

|externalCallbackUrl
|NO
|NOT_SUPPORTED
|N/A
|If the callback endpoint is behind a proxy or should be accessed through a non direct URL, use this parameter to tell the OAuth provider the URL it should use to access the callback

|resourceOwnerId
|YES
|SUPPORTED
|N/A
|The resourceOwnerId which each component should use if it doesn’t reference otherwise. 

|objectStore
|NO
|NOT_SUPPORTED
|N/A
|A reference to the object store that should be used to store each resource owner id’s data. If not specified, runtime will automatically provision the default one.

|before
|NO
|NOT_SUPPORTED
|N/A
|The name of a flow to be executed right before starting the OAuth dance (see specific section about this below)

|after
|NO
|NOT_SUPPORTED
|N/A
|The name of a flow to be executed right after an accessToken has been received (see specific section about this below)
|===

== About the use of expressions

As you can see in the table above, many of the synthetic parameters accept expressions. Using expressions there has the same effect 
as using expressions in a regular parameter: it will turn the configuration into a dynamic one. 

== OAuth Connection DSL

This is how the generated DSL  would look like:

[source, xml, linenums]
----
<sfdc:config name="salesforce">
    <sfdc:oauth-connection display="PAGE" immediate="FALSE" prompt="CONSENT">
        <sfdc:oauth-authorization-code consumerKey="${sfdc.consumerkey}" consumerSecret="${sfdc.consumersecret}" authorizationUrl="http://..." 
accessTokenUrl="http://..."/
localAuthorizationUrl="http://localhost:8080/.." scope="this that and those" resourceOwnerId="#[ownerId]"
before="myBeforeFlow" after="myAfterFlow" />
        <sfdc:oauth-callback-config listenerConfig="myHtttpListener" callbackPath="/callback” authorizePath="/authorize" />
        <sfdc:oauth-store-config objectStore="oauthObjectStore" />
</sfdc:config>
----

Take aways:

* Regular and OAuth parameters are all shown at the connection provider level, just like in any other provider
* The parameters related to the Authorization Code Grant type (`consumerKey`, `consumerSecret`, `authorizationUrl`, `accessTokenUrl`, 
`localAuthorizationHost`, `localAuthorizationPort`, `localAuthorizationPath`, `before`, `after`, `scope`, `defaultResourceOwnerId`) will be 
placed on a child element called `<oauth-authorization-code>`
* The parameters related to the callback, will be placed in a child element called `<oauth-callback-config>`
* The parameters related to object store, will be placed in a child element called `<oauth-store-config>`

== Custom Logic Before & After dance

Many times users will want to execute some random logic just before initiating the OAuth dance or right after it has been completed.
Example use cases of this is notifying an external system that a given owner id has been successfully on-boarded, keeping activity logs, etc.

Because now the authorization process is triggered by hitting an automatically created endpoint, is why the `<oauth-authorization-code>` 
child element has the `before` and `after` parameters that were previously discussed. 

These optional parameters should be used to specify the name of a `<flow>` to be invoked before or after the OAuth dance.

=== Before flow

The before flow will be executed just before the OAuth dance is started. The payload of the event sent to that flow will be an instance of 
`AuthorizationCodeRequest`, which is an immutable pojo that looks like this:

[source, java, linenums]
----
public interface AuthCodeRequest {

  /**
   * @return The id of the user being authenticated
   */
  String getResourceOwnerId();

  /**
   * @return The scopes that were requested
   */
  Optional<String> getScopes();

  /**
   * @return The OAuth state that was sent
   */
  Optional<String> getState();

  /**
   * @return The external callback url that the user configured or {@link Optional#empty()} if none was provided
   */
  Optional<String> getExternalCallbackUrl();
}
----

In this flow the user can perform any custom logic as needed. Specially, the user can set flow variables which, if you keep reading, 
can become pretty helpful.

=== After Flow
The after flow is executed right after the access token has been received and stored. This flow is executed with an event which 
is equivalent to that which came out of the before flow (or a blank event if no before flow was defined), except for the payload, 
which is replaced by the same `AuthorizationCodeState` object that is injected in the `ConnectionProvider`, but any variables which were 
previously set are still there (or will be empty if there was no before flow defined).

== Configuring a custom ObjectStore

The obtained access tokens are stored in an `ObjectStore`. By default, the SDK will store them in the application's default store, 
but users can define their own custom one:

[source,xml]
----
<os:object-store name="tokenStore" // <1>
   entryTtl="1"
   entryTtlUnit="HOURS"
   maxEntries="100"
   persistent="true"
   expirationInterval="30"
   expirationIntervalUnit="MINUTES" />

<sfdc:config name="salesforce">
    <sfdc:oauth-connection display="PAGE" immediate="FALSE" prompt="CONSENT">
        <sfdc:oauth-authorization-code consumerKey="${sfdc.consumerkey}" consumerSecret="${sfdc.consumersecret}"
        authorizationUrl="http://..." accessTokenUrl="http://..."/ 
        localAuthorizationUrl="http://localhost:8080/.." />
        <sfdc:oauth-callback-config listenerConfig="myHtttpListener" callbackPath="/callback” authorizePath="/authorize" />
        <sfdc:oauth-store-config objectStore="tokenStore" /> // <2>
</sfdc:config>
----

<1> Define your custom store
<2> Reference it on your module's config

== Next step

* <<_oauth_dance, Performing the OAuth dance with an OAuth enabled module>>
