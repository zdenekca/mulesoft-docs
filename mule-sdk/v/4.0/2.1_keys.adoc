[[_metadata_keys]]
= Metadata Keys Parameter

In order to describe a Dynamic Metadata structure, we need to
know what type has to be represented.
This type reference is done by defining a `@MetadataKeyId` Parameter in
the operation, that contains the id of the type (eg, Account) which will
be passed to the Metadata Resolver defined for that Parameter.

This means, for example, that if your Operation can save a generic
record to Amazon S3, but you wish to provide a better design time
experience by describing the supported types `Account` and
`Organization`, then one of your Operation parameters will be a type
reference containing either the id `Account` or the id `Organization`,
and this parameter will be used to describe either the Account
structure or the Organization structure for the record to be saved
into the bucket, depending on what the app developer decides to use.

== Providing a List of Metadata Keys

The most common case when resolving dynamic Metadata is to have a dynamic
set of keys that identify each of the possible types to be resolved.
At design time, the app developer will configure the Connector,
select an operation and choose one of those keys from the Set that get's
populated dynamically and the selected key will be come the `MetadataKeyId`
for the Metadata resolution.


Implementing the dynamic key's resolution starts with having a `TypeKeysResolver`:

.EntityKeysResolver.java
[source,java,linenums]
----
public class EntityKeysResolver implements TypeKeysResolver {

  @Override
  public String getCategoryName() {
    return "DocEntities";
  }

  @Override
  public Set<MetadataKey> getKeys(MetadataContext context) throws MetadataResolvingException, ConnectionException {
    return fetchKeyIds(context)
      .stream()
      .map(id -> MetadataKeyBuilder
        .newKey(id)
        .withDisplayName(StringUtils.removeEnd(id, "_id"))
        .build())
      .collect(Collectors.toSet());
  }

  private List<String> fetchKeyIds(MetadataContext context){
    // This is where you'd normally use `context.getConfig()`
    // or `context.getConnection()` to obtain the entity id's
    // from a remote service, for this demo the keys will be fixed
    return Arrays.asList("Author_id", "BookList_id", "Book_id");
  }

}
----

Here we can see all the elements required to create a dynamic Set of
MetadataKeys. The method to implement is `getKeys`, being it's output
all the keys that will be available for the user.

The `id` element, like `Author_id` will be used internally and has to
be unique for each structure you may want to represent across all the
resolvers. On the other hand, the `displayName` is the name that
will be shown to the user for that key, so it is expected to be more
human friendly.

image::metadata/keys_single_drop.png[MetadataKeys Single Level Dropdown]

Once the resolver is defined we can use it an Operation or Source,
associating the resolver to a given `MetadataKeyId` Parameter.
This will be explained in detail in the next section.

//TODO multilevel metadata keys
