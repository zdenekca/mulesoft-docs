= Web Service Consumer
:keywords: core, connector, web service consumer
:toc:
:toc-title: Page Contents

toc::[]



Use the web service consumer to configure a connection to a SOAP service, when there is not an Anypoint Connector available for a service.


== What is the Web Service Consumer?

This Mule core extension consists of a configuration with a single connection provider that returns instances of connections based on a WSDL definition, returns a specific service and port and, optionally, the service address (we take the one bound in the binding as default).

The connector is based on CXF to handle all the SOAP message parsing and building.
//MG how based on CXF?
// http://cxf.apache.org/docs/why-cxf.html

The web service consumer has a single operation, the *Consume* operation. It provides all the available operations for the given connection and only accepts a SOAP message valid for the selected SOAP operation.

[NOTE]
As with the old module, the underlying transport can be configured. By default, it uses HTTP, however you can configure both JMS and a more complex HTTP setup.
//MG what do we mean by simple configuration


== Features

* Full metadata support for headers, body and attachments (including for multipart SOAP message operations) for both input and output.
* Message Transmission Optimization Mechanism (MTOM) attachments
* SOAP attachments
* SOAP multipart messages
* SOAP headers
* Web Service Security (Timestamp, UsernameToken, Signature, Encryption)
* Custom transport configuration (HTTP, JMS)

== How to Configure the Web Service Consumer

Configuring the WSC means entering the connection details. The configuration for the web service consumer is basically a container for the connection. It only has one optional attribute, the *encoding*. The provided encoding is used in all  requests and responses managed by the *Consume* operation. If no encoding is specified, the web service consumer uses Mule's default encoding.
//configuration/container and the connection. Configuring the WSC means entering the connection details.

[source,xml,linenums]
----
<wsc:config name="config"  encoding="UTF-8">
	<wsc:connection … />
</wsc:config>
----

=== How to Create a Connection

To connect with a SOAP service, three parameters must be provided:

* *WSDL* location (URL or a local file),
* *service name* from the specified *WSDL*
* *port name* for the specified *service name*

By default, the service looks for the address in the *WSDL* with the binding that defines the provided service and port. Also, you can specify the SOAP version that you want to build the request for with link:https://www.w3.org/TR/2000/NOTE-SOAP-20000508/[SOAP 1.1] configured as the default.


[source,xml,linenus]
----
<wsc:connection service="aService"
  port="aPort"
  wsdlLocation="http://www.serviceAddress.com/path?wsdl"
  soapVersion="SOAP12"/>
----

The connection parses the WSDL file you specify and loads all the referenced schemas to find the types and elements as needed.
//MG a connection parses the wsdl?

If the SOAP server supports MTOM, the connection can have MTOM enabled using the `mtomEnabled` flag. This sends all the attachments for the operations in an HTTP multipart message (if JMS is configured as the underlying transport, this is not possible). MTOM is disabled by default.

[source,xml]
----
<wsc:connection service="aService" port="aPort" wsdlLocation="...?wsdl" mtomEnabled="true"/>
----
//If JMS is enabled, what does this mean for MTOM then? Are these two features mutually exclusive?

All connections created by the web service consumer are reusable and the provider is implemented as a `PoolingConnectionProvider`.

=== How to Configure Web Service Security

//MG what is WS-security, under the hood?
Define `<wsc:security-strategies>` supporting one or many of the below security strategies.

The web service consumer provides the capability to add security for the outgoing and incoming SOAP messages, the supported security mechanisms are:

 * Timestamp
 * Sign
 * verifySignature
 * Encryption
 * Decryption
 * UsernameToken

==== UsernameToken

Adds a username token to the outgoing SOAP message.

[source,xml,linenums]
----
<wsc:connection wsdlLocation="http://.../usernameToken?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
       <wsc:wss-username-token-security-strategy
      username="admin"
      password="textPassword"
      passwordType="TEXT"
      addCreated="true"
      addNonce="true"/>
   </wsc:security-strategies>
</wsc:connection>
----

This security strategy exposes the following configuration attributes:

* `username`: Defines the username to access Web service; added to header of request sent to Web service.
* `password`: *Defines the password to access Web service; added to header of request sent to Web service.
* `passwordType`: This specifies how the password should be serialized, *DIGEST* or *TEXT*. The _password digest_ option is non-standard and should only be used for interop issues where the message receiver desires an extra SHA-1 Hash of the password. Defaults to *TEXT.*
* `addCreated`: Specifies whether or not to add a "Created" header to the Web service request. Defaults to *_false_*
* `addNonce`: Specifies whether or not to add a "Nonce" header to the Web service request. Defaults to *_false_*

==== Timestamp

Adds a timestamp entry to the outgoing message, it only contains two attributes: `timeToLive` and `timeToLiveUnit`.

[source,xml,linenums]
----
<wsc:connection wsdlLocation="http://.../sign?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
       <wsc:wss-timestamp-security-strategy
         timeToLive="1"
         timeToLiveUnit="MINUTES"/>
   </wsc:security-strategies>
</wsc:connection>
----

* `timeToLive`: Length of time the message is valid. This attributes is qualified by the `timeToLiveUnit` attribute. The default value is 60 (seconds, qualified by the time unit `timeToLiveUnit`).  +
* `timeToLiveUnit`: Unit of time which qualifies the `timeToLive` attribute. The default is `SECONDS`.

==== Signature

Signs the outgoing message using the keystore configuration provided.


[source,xml,linenums]
----
<wsc:connection wsdlLocation="http://.../sign?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
      <wsc:wss-sign-security-strategy>
          <wsc:key-store-configuration
          keyStorePath="path/To/Key/Store"
          password="changeit"
          alias="s1as"
          type="jks"/>
      </wsc:wss-sign-security-strategy>
   </wsc:security-strategies>
</wsc:connection>
----


==== Verify Signature

Validates the signature of an incoming SOAP message using the truststore configuration provided.

[source,xml,linenums]
----
<wsc:connection wsdlLocation="http://.../sign?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
      <wsc:wss-verify-signature-security-strategy>
         <wsc:trust-store-configuration
         trustStorePath="path/To/TrustStore"
         password="mulepassword"/>
      </wsc:wss-verify-signature-security-strategy>
   </wsc:security-strategies>
</wsc:connection>
----

==== Encrypt

Encrypts the body of an outgoing SOAP message using the keystore configuration provided

[source,xml,linenums]
----
<wsc:connection wsdlLocation="http://.../sign?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
      <wsc:wss-encrypt-security-strategy>
          <wsc:key-store-configuration keyStorePath="path/To/Key/Store"
          password="changeit"
          alias="s1as"
          type="jks"/>
      </wsc:wss-encrypt-security-strategy>
   </wsc:security-strategies>
</wsc:connection>
----

==== Decrypt

Decrypts the body of an incoming soap message using the Keystore configuration provided.

[source,xml,linenums]
----
<wsc:connection wsdlLocation="http://.../sign?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
      <wsc:wss-decrypt-security-strategy>
          <wsc:key-store-configuration
          keyStorePath="path/To/Key/Store"
          password="changeit"
          alias="s1as"
          type="jks"/>
      </wsc:wss-decrypt-security-strategy>
   </wsc:security-strategies>
</wsc:connection>
----

==== Keystore and Truststore Configurations

The following sections provide Keystore and Truststore configurations.

==== Keystore Configuration

Enables the configuration of keystore for signing, encrypting or decrypting. It's basically a simple POJO with 5 fields:

* `keyStorePath`: the location of the keyStoreFile.
* `password`: the password used to access the store.
* `alias`: the alias of the private key to use.
* `keyPassword`: the password used to access the private key. If required.
* `type`: the type of store (jks, pkcs12, jceks). Defaults to `jks`.

[source,xml,linenums]
----
<wsc:key-store-configuration
  keyStorePath="path/To/Key/Store"
  password="changeit"
  alias="s1as"
  keyPassword="asdasd123123"
  type="jks"/>
----

==== Truststore Configuration

Enables the configuration of truststore for verifying signatures. It's basically a simple POJO with 3 fields:

 * `trustStorePath`: the location of the trustStore file.
 * `password`: the password used to access the store.
 * `type`: the type of store (jks, pkcs12, jceks). Defaults to `jks`.

[source,xml,linenums]
----
<wsc:trust-store-configuration  trustStorePath="path/To/TrustStore"
password="enterpassword"
type="jks"/>
----

Both keystore and truststore configuration can be defined as global elements so they can be reused in different configurations.

[source,xml,linenums]
----
<wsc:key-store-configuration
  name="keyStoreGlobalConfig"
  keyStorePath="path/To/Key/Store"
  password="changeit"
  alias="s1as" type="jks"/>

<wsc:connection wsdlLocation="http://.../sign?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
      <wsc:wss-decrypt-security-strategy name="keyStoreGlobalConfig"/>
   </wsc:security-strategies>
</wsc:connection>
----


=== How to Use Multiple Security Strategies

Declaring multiple security strategies is valid.

Here is an example of a WSC consumer connection secured with encryption, decryption and timestamp.

[source,xml,linenums]
----
<wsc:connection wsdlLocation="http://.../sign?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
      <wsc:wss-timestamp-security-strategy timeToLive="1" timeToLiveUnit="MINUTES"/>
           <wsc:wss-encrypt-security-strategy>
          <wsc:key-store-configuration keyStorePath="path/To/Key/Store"
          password="changeit"
          alias="s1as"
          type="jks"/>
      </wsc:wss-encrypt-security-strategy>
      <wsc:wss-decrypt-security-strategy>
          <wsc:key-store-configuration keyStorePath="path/To/Key/Store2"
          password="changeit"
          alias="anotherAlias"
          type="jks"/>
      </wsc:wss-decrypt-security-strategy>
   </wsc:security-strategies>
</wsc:connection>
----

////
=== Connection Validation

*TBD*
//MG
////

== The Consume Operation

The *Consume* operation is the only web service consumer operation. It enables the execution of a web service operation providing the required information for the specific operation to execute.

Basically the idea behind the operation is that for a connection, expose a set of SOAP operations to execute. For the connection you want to consume, select the required header types, body type, and attachments it has if any; and also describe the output message of the operation.

The *Consume* operation requires only two parameters:

* Operation
* Message that represents the SOAP Message that is going to be built

The SOAP message consist of three parameters:

 * `headers`: A set of XML headers
 * `body`: The XML body, or null, if no body elements are required
 * `attachments`:  A set of attachments

The output can be of two different types dependending whether the response contains attachments or not. 
If the response does not carry any attachments the resulting type is a plain XML with the information returned by the service, but if the response does return at least one attachment the output type is a Multipart payload that carries the plain XML response in the body, and contains another part for each retrieved attachment by the service.


[source,xml,linenums]
----
<wsc:consume config-ref="attachmentsConfig" operation="uploadAttachment">
   <wsc:message>
       <wsc:headers>
          <wsc:header value="#[flowVars.headerIn]" key="headerIn"/>
          <wsc:header value="#[flowVars.headerInOut]" key="headerInOut"/>
       </wsc:headers>
       <wsc:body>#[payload]</wsc:body>
       <wsc:attachments>
           <wsc:attachment key="attachment" value="#[flowVars.inAttachment]"/>
       </wsc:attachments>
   </wsc:message>
</wsc:consume>
----

=== Operation Input

The input consist of a *Message* that represents a SOAP message. Input is composed of the body, a set of headers, and a set of attachments, all of them optional parameters.

==== Body

The `input` body for an operation is XML that follows the element definition pointed to by the `message` block in the provided WSDL.

For example given a SOAP operation definition (extracted from a WSDL file) like this one:

[source,xml,linenums]
----
<operation name="echoAccount">
   <soap:operation soapAction="echoAccount"/>
   <input>
       <soap:body use="literal"/>
   </input>
   <output>
       <soap:body use="literal"/>
   </output>
</operation>
…
<-- with this message definition !-->
<message name="echoAccount">
   <part name="parameters" element="tns:account"/>
</message>
<-- with the this account type definition !-->
<xs:complexType name="account">
   <xs:sequence>
     <xs:element name="id" type="xs:long" minOccurs="0"/>
       <xs:element name="items" type="xs:string" nillable="true" minOccurs="0"/>
       <xs:element name="startingDate" type="xs:dateTime" minOccurs="0"/>
</xs:sequence>
----

The body expects content like this to generate a correct SOAP envelope:

[source,xml,linenums]
----
<con:echoAccount xmlns:con="http://consumer.ws.extension.mule.org/">
   <account>
       <id>12</id>
       <items>chocolate</items>
       <items>caramel</items>
       <items>vanilla</items>
       <startingDate>2016-09-23T00:00:00-03:00</startingDate>
   </account>
</con:echoAccount>
----

Metadata is provided to build the XML body using link:/mule-user-guide/v/3.8/dataweave[DataWeave].

===== No Body Required

When an operation doesn't have a required body, use the Consume operation to accept a null value as body, 
and to generate the required body part without parameters to fulfill the SOAP request.

An example autogenerated body:

[source,xml,linenums]
----
<con:operationName xmlns:con="http://consumer.ws.extension.mule.org/"/>
----

We only need the operation's *Qname* to generate the empty body request.

===== Body Attachment Elements

In a SOAP context, the attachments are part of the body, the attachment could travel encoded to base64 right in the body or have a reference to a part of a multipart HTTP message for example, using MTOM. For the Consume operation, this is not a concern and the body is agnostic of the attachments. They are handled internally and the user does not need to worry about adding that attachment elements to the request body.

==== Headers

The headers are defined as a Map where each entry represents a header, the key of the entry defines the name of the header and the value is the header XML element.

For example if a header is defined like this:

[source,xml,linenums]
----
<wsc:message>
   <wsc:headers>
      <wsc:header value="#[payload]" key="headerIn"/>
   </wsc:headers>
</wsc:message>
----

The payload carries this header:

[source,xml]
----
<con:headerIn  xmlns:con="http://service.ns/">Header In Value</con:headerIn>
----

Metadata is provided to build the headers using DataWeave. All keys should be auto populated with their values so the user should only set the content for each one of the headers.

[source,xml]
----
{
  headerIn: "<con:headerIn  xmlns:con="http://service.ns/">Header In Value</con:headerIn>",
  headerNumberTwo: "<ns:someHeader/>"
}
----

==== Attachments

The SOAP protocol attachments are carried in the body. The WSC supports SOAP with attachments that encode the body to base64 and travel embedded into the body request and also support *MTOM*, a method of efficiently sending binary data to and from Web services. MTOM introduces the concept of sending the binary data separately from the XML body by including an XML-binary Optimized Packaging (XOP) in place of the binary data that references the data that travels in a *multipart/related message*.

.SOAP with attachments
[source,xml,linenums]
----
<con:uploadAttachment xmlns:con="http://consumer.ws.extension.mule.org/">
   <name>picture</name>
   <attachment>VGhpcyBpcyBhIHBpY3R1cmUgY29udGVudA==</attachment>
</con:echoAccount>
----

.MTOM
[source,xml,linenums]
----
<con:uploadAttachment xmlns:con="http://consumer.ws.extension.mule.org/">
   <name>picture</name>
   <xop:include href="cid:SomeUniqueID"/>
</con:echoAccount>
----

*With a MIME attachment:*

----
Content-id: "SomeUniqueID"
Content-Type: image/png

VGhpcyBpcyBhIHBpY3R1cmUgY29udGVudA==
----

For both cases the attachments are handled the same way, the WSC adds the information that is required to the body, depending on the connection you use.

=== Operation Output

The output of the operation is composed by the output payload and a set of attributes.

Both attributes and payload output provides metadata.

==== Output Payload

The output of the Consume operation can be a plain XML with the response body returned by the service or a Multipart Payload with the XML response as body of the Multipart and one more part for each attachment returned by the SOAP service.

==== Output Attributes

Web service attributes are returned for each Consume operation invocation, together with the output payload.

These attributes carry all the headers returned by the SOAP service (SOAP Headers) in XML format and all protocol specific headers returned upon operation request.
