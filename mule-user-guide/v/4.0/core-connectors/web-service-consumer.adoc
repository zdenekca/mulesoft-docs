= Web Service Consumer
:keywords: core, connector, web service consumer
:toc:
:toc-title: Page Contents

toc::[]



Use the web service consumer to configure a connection to a SOAP service.

== Features

* Full metadata support for headers, body and attachments (including for multipart soap message operations) for both input and output.
* MTOM attachments
* SOAP attachments
* SOAP multipart messages
* SOAP Headers
* Web Service Security (Timestamp, UsernameToken, Signature, Encryption)
* Custom transport configuration (HTTP, JMS)

== What is the Web Service Consumer?

This Mule core extension consists of a configuration with a single connection provider that returns instances of connections based on a WSDL definition, returns a specific service and port and, optionally, the service address (we take the one bound in the binding as default).

The connector is based on CXF to handle all the SOAP message parsing and building.
//MG how based on CXF?
// http://cxf.apache.org/docs/why-cxf.html

The web service consumer has a single operation, the *Consume* operation. It provides all the available operations for the given connection and only accepts a SOAP message valid for the selected SOAP operation.

[NOTE]
As with the old module, the underlying transport can be configured. By default, it uses HTTP with a simple configuration, however both JMS and HTTP can be configured.
//MG what do we mean by simple configuration

== Configuration

Configuring the WSC means entering the connection details. The configuration for the web service consumer is basically a container for the connection. It only has one optional attribute: the *encoding*. The provided encoding will be used in all the requests and responses managed by the *Consume* operation. If none specified, the web service consumer uses Mule's default encoding.
//configuration/container and the connection. Configuring the WSC means entering the connection details.

[source,xml,linenums]
----
<wsc:config name="config"  encoding="UTF-8">
	<wsc:connection … />
</wsc:config>
----

== Connection

To connect with a SOAP service, three parameters must be provided:

* *WSDL* location (URL or a local file),
* *service name* from the specified *WSDL*
* *port name* for the specified *service name*

By default, the service looks for the address in the *WSDL* with the binding that defines the provided service and port. Also, you can specify the SOAP version that you want to build the request for with link:https://www.w3.org/TR/2000/NOTE-SOAP-20000508/[SOAP 1.1] configured as the default.


[source,xml,linenus]
----
<wsc:connection service="aService"
  port="aPort"
  wsdlLocation="http://www.serviceAddress.com/path?wsdl"
  soapVersion="SOAP12"/>
----

The connection parses the provided WSDL file and loads all the referenced schemas to find the types and elements as needed.
//MG a connection parses the wsdl?

If the SOAP server supports MTOM the connection can have MTOM enabled using the `mtomEnabled` flag. What this does is send all the attachments for the operations in an HTTP multipart message (if JMS is configured as the underlying transport this is not possible). MTOM is disabled by default.

[source,xml,linenums]
----
<wsc:connection service="aService" port="aPort" wsdlLocation="...?wsdl" mtomEnabled="true"/>
----
//If JMS is enabled, what does this mean for MTOM then? Are these two features mutually exclusive


All connections created by the web service consumer are reusable and the provider is implemented as a `PoolingConnectionProvider`.

== Underlying Transport

//MG "TO BE DEFINED" - please consider if this section is valid

The connection is able to fetch remote secured WSDL files since the request is performed using the provided transport configuration. Basically you can connect through a secured WSDL with the same underlying transport configuration used for consuming the service.

== Web Service Security
//MG what is WS-security, under the hood?

The web service consumer provides the capability to add security for the outgoing and incoming SOAP messages, the supported security mechanisms that provides are:

 * Timestamp
 * Sign
 * verifySignature
 * Encryption
 * Decryption
 * UsernameToken

=== UsernameToken

Adds a username token to the outgoing SOAP message.

[source,xml,linenums]
----
<wsc:connection wsdlLocation="http://.../usernameToken?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
       <wsc:wss-username-token-security-strategy
      username="admin"
      password="textPassword"
      passwordType="TEXT"
      addCreated="true"
      addNonce="true"/>
   </wsc:security-strategies>
</wsc:connection>
----

This security strategy exposes the following configuration attributes:

* `username`: Defines the username to access Web service; added to header of request sent to Web service.
* *password: *Defines the password to access Web service; added to header of request sent to Web service.
* `passwordType`: This specifies how the password should be serialized, *DIGEST* or *TEXT*. The _password digest_ option is non-standard and should only be used for interop issues where the message receiver desires an extra SHA-1 Hash of the password. Defaults to *TEXT.*
* `addCreated`: Specifies whether or not to add a "Created" header to the Web service request. Defaults to *_false_*
* `addNonce`: Specifies whether or not to add a "Nonce" header to the Web service request. Defaults to *_false_*

=== Timestamp

Adds a timestamp entry to the outgoing message, it only contains two attributes: `timeToLive` and `timeToLiveUnit`.

[source,xml,linenums]
----
<wsc:connection wsdlLocation="http://.../sign?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
       <wsc:wss-timestamp-security-strategy
         timeToLive="1"
         timeToLiveUnit="MINUTES"/>
   </wsc:security-strategies>
</wsc:connection>
----

`timeToLive`: length of time the message is valid. This attributes is qualified by the `timeToLiveUnit` attribute. The default value is 60 (seconds, qualified by the time unit `timeToLiveUnit`).  +
`timeToLiveUnit`: unit of time which qualifies the `timeToLive` attribute. The default is `SECONDS`.

=== Signature

Signs the outgoing message using the keystore configuration provided.


[source,xml,linenums]
----
<wsc:connection wsdlLocation="http://.../sign?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
      <wsc:wss-sign-security-strategy>
          <wsc:key-store-configuration
          keyStorePath="path/To/Key/Store"
          password="changeit"
          alias="s1as"
          type="jks"/>
      </wsc:wss-sign-security-strategy>
   </wsc:security-strategies>
</wsc:connection>
----


=== Verify Signature

Validates the signature of an incoming SOAP message using the truststore configuration provided.

[source,xml,linenums]
----
<wsc:connection wsdlLocation="http://.../sign?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
      <wsc:wss-verify-signature-security-strategy>
         <wsc:trust-store-configuration
         trustStorePath="path/To/TrustStore"
         password="mulepassword"/>
      </wsc:wss-verify-signature-security-strategy>
   </wsc:security-strategies>
</wsc:connection>
----

=== Encrypt

Encrypts the body of an outgoing SOAP message using the keystore configuration provided

[source,xml,linenums]
----
<wsc:connection wsdlLocation="http://.../sign?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
      <wsc:wss-encrypt-security-strategy>
          <wsc:key-store-configuration keyStorePath="path/To/Key/Store"
          password="changeit"
          alias="s1as"
          type="jks"/>
      </wsc:wss-encrypt-security-strategy>
   </wsc:security-strategies>
</wsc:connection>
----

=== Decrypt

Decrypts the body of an incoming soap message using the Keystore configuration provided.

[source,xml,linenums]
----
<wsc:connection wsdlLocation="http://.../sign?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
      <wsc:wss-decrypt-security-strategy>
          <wsc:key-store-configuration
          keyStorePath="path/To/Key/Store"
          password="changeit"
          alias="s1as"
          type="jks"/>
      </wsc:wss-decrypt-security-strategy>
   </wsc:security-strategies>
</wsc:connection>
----

=== Keystore and Truststore Configurations

Enables the configuration of keystore for signing, encrypting or decrypting. It's basically a simple POJO with 5 fields:

* `keyStorePath`: the location of the keyStoreFile.
* `password`: the password used to access the store.
* `alias`: the alias of the private key to use.
* `keyPassword`: the password used to access the private key. If required.
* `type`: the type of store (jks, pkcs12, jceks). Defaults to `jks`.

[source,xml,linenums]
----
<wsc:key-store-configuration
  keyStorePath="path/To/Key/Store"
  password="changeit"
  alias="s1as"
  keyPassword="asdasd123123"
  type="jks"/>
----

=== The Truststore Configuration

Enables the configuration of truststore for verifying signatures. It's basically a simple POJO with 3 fields:

 * `trustStorePath`: the location of the trustStore file.
 * `password`: the password used to access the store.
 * `type`: the type of store (jks, pkcs12, jceks). Defaults to `jks`.

[source,xml,linenums]
----
<wsc:trust-store-configuration  trustStorePath="path/To/TrustStore"
password="enterpassword"
type="jks"/>
----

Both keystore and truststore configuration can be defined as global elements so they can be reused in different configurations.

[source,xml,linenums]
----
<wsc:key-store-configuration
  name="keyStoreGlobalConfig"
  keyStorePath="path/To/Key/Store"
  password="changeit"
  alias="s1as" type="jks"/>

<wsc:connection wsdlLocation="http://.../sign?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
      <wsc:wss-decrypt-security-strategy name="keyStoreGlobalConfig"/>
   </wsc:security-strategies>
</wsc:connection>
----


=== Using Multiple Security Strategies

Declaring multiple security strategies is valid.

Here is an example of a WSC consumer connection secured with encryption, decryption and timestamp.

[source,xml,linenums]
----
<wsc:connection wsdlLocation="http://.../sign?wsdl" service="Service" port="Port">
   <wsc:security-strategies>
      <wsc:wss-timestamp-security-strategy timeToLive="1" timeToLiveUnit="MINUTES"/>
           <wsc:wss-encrypt-security-strategy>
          <wsc:key-store-configuration keyStorePath="path/To/Key/Store"
          password="changeit"
          alias="s1as"
          type="jks"/>
      </wsc:wss-encrypt-security-strategy>
      <wsc:wss-decrypt-security-strategy>
          <wsc:key-store-configuration keyStorePath="path/To/Key/Store2"
          password="changeit"
          alias="anotherAlias"
          type="jks"/>
      </wsc:wss-decrypt-security-strategy>
   </wsc:security-strategies>
</wsc:connection>
----

////
=== Connection Validation

*TBD*
//MG
////

== Consume Operation

The *Consume* operation is the only web service consumer operation. It enables the consumption of a web service operation providing the required information for the specific operation that is wanted to execute.

Basically the idea behind the operation is that for the given connection, exposes a set of soap operations that can be executed, and selecting the one it's wanted to consume describes the required headers types, the body type and the attachments if has any; and will also describe the output message of the operation.

The *Consume* operation requires only two parameters:
* the operation and
* message that represents the SOAP Message that is going to be built.

The soap message consist of three parameters:

 * `headers`: a set of XML headers.
 * `body`: the XML body or null if no body elements are required.
 * `attachments`:  a set of attachments

And the output can be of two different types dependending whether the response contains attachments or not. If the response does not carry any attachments the resulting type will be a plain XML with the information returned by the service, but if the response does return at least one attachment the output type will be a Multipart payload that carries the plain XML response in the body and another part for each retrieved attachment by the service.


[source,xml,linenums]
----
<wsc:consume config-ref="attachmentsConfig" operation="uploadAttachment">
   <wsc:message>
       <wsc:headers>
          <wsc:header value="#[flowVars.headerIn]" key="headerIn"/>
          <wsc:header value="#[flowVars.headerInOut]" key="headerInOut"/>
       </wsc:headers>
       <wsc:body>#[payload]</wsc:body>
       <wsc:attachments>
           <wsc:attachment key="attachment" value="#[flowVars.inAttachment]"/>
       </wsc:attachments>
   </wsc:message>
</wsc:consume>
----

=== Operation Input

The input consist on a *Message* that represents a SOAP message and it's composed by the body, a set of headers and a set of attachments, all of them optional parameters.

==== Body

The input body for an operation is an XML that follows the element definition pointed by the message part in the provided wsdl.

For example given a soap operation definition (extracted from a wsdl file) like this one:

[source,xml,linenums]
----
<operation name="echoAccount">
   <soap:operation soapAction="echoAccount"/>
   <input>
       <soap:body use="literal"/>
   </input>
   <output>
       <soap:body use="literal"/>
   </output>
</operation>
…
<-- with this message definition !-->
<message name="echoAccount">
   <part name="parameters" element="tns:account"/>
</message>
<-- with the this account type definition !-->
<xs:complexType name="account">
   <xs:sequence>
     <xs:element name="id" type="xs:long" minOccurs="0"/>
       <xs:element name="items" type="xs:string" nillable="true" minOccurs="0"/>
       <xs:element name="startingDate" type="xs:dateTime" minOccurs="0"/>
</xs:sequence>
----

The body expects content like this in order to generate a correct SOAP envelope:

[source,xml,linenums]
----
<con:echoAccount xmlns:con="http://consumer.ws.extension.mule.org/">
   <account>
       <id>12</id>
       <items>chocolate</items>
       <items>caramel</items>
       <items>vanilla</items>
       <startingDate>2016-09-23T00:00:00-03:00</startingDate>
   </account>
</con:echoAccount>
----

Metadata is provided to build the XML body using dataweave.

===== No Body Required

When an operation hasn't a required body the Consume Operation accepts a null value as body and generates the required body part without parameters to fulfill the SOAP request.

An example autogenerated body:

[source,xml,linenums]
----
<con:operationName xmlns:con="http://consumer.ws.extension.mule.org/"/>
----

We only need the operation's *Qname* to generate the empty body request.

===== Body attachment elements

In a soap context the attachments are part of the body, the attachment could travel encoded to base64 right in the body or have a reference to a part of a multipart http message for example (MTOM). For the Consume operation this is not a concern and the body is agnostic of the attachments, they are handled internally and the user does not need to worry about adding that attachments elements to the request body.

==== Headers

The headers are defined as a Map where each entry represents a header, the key of the entry defines the name of the header and the value is the header XML element.

For example having a header defined like this:

[source,xml,linenums]
----
<wsc:message>
   <wsc:headers>
      <wsc:header value="#[payload]" key="headerIn"/>
   </wsc:headers>
</wsc:message>
----

Where the payload carries this header:

[source,xml,linenums]
----
<con:headerIn  xmlns:con="http://service.ns/">Header In Value</con:headerIn>
----

Of course, metadata is provided to build the headers using dataweave and all keys should be auto populated with their values so the user should only set the content for each one of the headers.

----
{
  headerIn: "<con:headerIn  xmlns:con="http://service.ns/">Header In Value</con:headerIn>",
  headerNumberTwo: "<ns:someHeader/>"
}
----

==== Attachments

The SOAP protocol attachments are carried in the body. The WSC supports Soap with attachments that encodes the body to base64 and travels embedded into the body request and also supports *MTOM* (_Message Transmission Optimization Mechanism_) a method of efficiently sending binary data to and from Web services. Mtom introduces the concept of sending the binary data separately from the XML body by including an XML-binary Optimized Packaging (XOP) in place of the binary data that references the data that travels in a *multipart/related *message.

.SOAP with attachments
[source,xml,linenums]
----
<con:uploadAttachment xmlns:con="http://consumer.ws.extension.mule.org/">
   <name>picture</name>
   <attachment>VGhpcyBpcyBhIHBpY3R1cmUgY29udGVudA==</attachment>
</con:echoAccount>
----

.MTOM
[source,xml,linenums]
----
<con:uploadAttachment xmlns:con="http://consumer.ws.extension.mule.org/">
   <name>picture</name>
   <xop:include href="cid:SomeUniqueID"/>
</con:echoAccount>
----

*With a MIME-attachment like this one*

----
Content-id: "SomeUniqueID"
Content-Type: image/png

VGhpcyBpcyBhIHBpY3R1cmUgY29udGVudA==
----

For both cases the attachments are handled the same way, the WSC adds the information that is required to the body depending on the connection that is being used.

=== Operation Output

The output of the operation is composed by the output payload and a set of attributes.

Both attributes and payload output provides metadata.

==== Output Payload

The output of the consume operation can be a plain XML with the response body returned by the service or a Multipart Payload with the XML response as body of the Multipart and one more part for each attachment returned by the SOAP service.

==== Output Attributes

There is also a set of Web service Attributes that are returned for each consume operation invocation, together with the output payload.  +
This attributes carries all the headers that are returned by the soap service (Soap Headers) in XML format and all protocol specific headers returned once the request was performed.
