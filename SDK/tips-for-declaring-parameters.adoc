= Tips for Declaring Parameters


Before moving on, see the basic formula for link:/to-declare-parameters[Declaring Parameters].

We recommend you annotate the parameters of your extension configurations and operations as per the guidance on setting configuration attributes with `@Parameter`, whenever possible. However, consider this before further coding.

== Mechanisms for Introspecting POJO Type Parameters

POJO type parameters are introspected in order to determine which parameters they contain. There are two ways this is done.

=== Annotated Fields Mechanism (Default and Recommended)

The default and recommended approach is to annotate the fields of a POJO with the same set of annotations as a config would. This provides the greatest level of control, is consistent with the rest of the extension development model and works with field level "injection".


=== JDK Introspector Mechanism

In cases where your extension must access a POJO that is defined in another .jar stored elsewhere, is shared with other projects or which cannot depend on extension annotations, the POJO is introspected using the JDK's "Introspector" class getters and setters to obtain its properties. Those properties are then turned into parameters. The downsides to this are:

* the parameters are assumed to be optional. There is no support for UI placement via `@Placement`, nor expression support via `@Expression`--defaults are always assumed
//MG: please explain above sentence--esp. "always assuming defaults" - see spec plz
* Value injection occurs through the setter instead of the field itself, as there is no mechanism to verify the setter and the corresponding field have matching names or even exist.
//MG the setter of the JDK operates on the parameter, not the Extensions API?


== Group Codependent Parameters

Groups of parameters which have a logical dependency on one another can be grouped; for example, connection parameters like "host", "port", "username" and "password" could be grouped in a single class using `@ParameterGroup`.

[source,java,linenums]
----
@Parameter
private String id;


@ParameterGroup(name = "Connection")
private ConnectionParameters connectionParameters;


final class ConnectionParameters
{


   @Parameter
   private String host;


	 @Parameter
	 private String port;
â€¦
}
----

Handle related items inside their own class.
From the model point of view, the `ConnectionParameters` class written above would be flattened and added to the component that declares it. The corresponding `ConfigurationModel` would list three parameters: `id`, `host` and `port`, without any reference to the `ConnectionParameters` object.

The same goes for operations:

[source,java,linenums]
----
public void sendMessage(@Content payload, @ParameterGroup(name = "Connection) connectionParameters) {
}
----

[IMPORTANT]
Do not use a `@ParameterGroup` annotation inside a complex object which is being used as a parameter group.

=== Restrain Parameters within Parameter Groups

When imposing restrictions on which parameters cannot be set at the same time as others, use `@ExclusiveOptionals` on the parameter group class. Notice how the `@Optional` is used to indicate the specific parameter to exclude.
//MG: in spec the example does not have the @ParameterGroup annotation, is this correct?


[source,java,linenums]
----
@ExclusiveOptionals(isOneRequired = true)
public class MyParameterGroup {


	@Parameter
	private Pojo notAffectedByExclusiveness;


	@Parameter
	@Optional
	private String name;


	@Parameter
	@Optional
	private Integer ID;
}
----
